# 1. 코어 스프링
스프링이 제공하는 기능은 매우 다양하지만, 핵심을 파고들면 스프링의 주요 기능은 종속 객체 주입(DI)와 애스펙트 지향 프로그램(AOP)으로 귀결된다.  
  
1장 스프링 속으로에서는 DI와 AOP의 기본적인 개념을 살펴보고, 두 기능이 애플리케이션 객체간의 결합도를 줄이는 데 어떻게 기여 하는지 알아본다.  
  
2장 빈 와이어링에서는 애플리케이션 컴포넌트들에 대해서 더 깊이 살펴본다. 스프링에서 제공되는 자동 설정, 자바 기반 설정 XML 선정 옵션에 대해 알아본다.  
  
3장 고급 와이어링에서는 오토와이어링, 스코핑 및 스프링 표현언어를 취급하고 조건적 설정 방법을 포함하여 스프리으이 최대 효과를 이끌어 낼 수 있는 몇 가지 트릭과 테크닉을 소개한다.  
    
4장 애스펙트 지향 스프링에서는 스프링의 AOP기능을 이용해 시스템 전반에 걸친 서비스와 그 서비스를 받는 객체 간의 결합도를 줄이는 방법을 살펴본다.  
그리고 4장에서는 9장, 13장, 14장에서 다루는 서술적 보안과 캐싱을 위한 스프링 AOP레버리지 방법의 기초를 다룬다.

<hr/>

<string>이장에서 다룰 내용</string>  

* 스프링의 빈 컨테이너
* 스프링 코어 모듈 살펴보기
* 더 훌룡해진 스프링 에코 시스템
* 스프링의 새로워진 점
<hr/>  
자바 개발자가 되기에 좋은 시절이다.  

## 자바개발 간소화
스프링은 로드 존슨의 책 Expert One-on-One을 통해 소개한 오픈 소스 프레임워크로서 엔터프라이즈 애플리케이션 개발의 복잡함을 해소하기 위해 만들어 졌다.  
스프링은 EJB로만 할 수 있었던 작업을 평범한 자바빈을 사용해 가능하게 한다.  
하지만 스프링이 서버 측 개발에만 유용한 것은 아니다.  
스프링을 사용하는 모든 자바 애플리케이션은 간소함, 테스트 용이, 낮은 결합도라는 이득을 얻는다.  

스프링이 애플리케이션 컴포넌트를 참조하면서 빈과 자바빈을 사용하지만, 반드시 자바빈의 스펙을 따라야 한다는 것을 의미하지는 않는다. 스프링 컴포넌트는 POJO 타입을 가진다. 여기서는 자바빈을 느슨하게 정의하며, POJO와 동일하다고 간주한다.  
  
이 책을 통해 스프링의 다양한 내용을 살펴보겠지만, 스프링이 제공하는 거의 모든 기본 사상은 몇 가지 기초적인 개념으로 귀결되며, 이는 스프링의 기본 임무인 '자바 개발 간소화'의 모든 초점을 맞춘다.
  
이것이 핵심이다. 특정 기능을 간소화 하는 프레임워크는 많이 존재한다. 하지만 스프링의 목적은 자바 개발을 폭넓게 간소화 하는데 있다.
이 내용에 관하여서는 더 많은 설명이 필요하다.
그러면 어떻게 자바 개발을 간소화 할 수 있을까?  

자바 복잡도 간소화를 지원하기 위해 스프링은 네 가지 주요 전략을 사용한다.  
* POJO를 이용한 가볍고 비 침투적인 개발  
* DI와 인터페이스 지향을 통한 느슨한 결합도
* 애스펙트와 공통 규약을 통한 선언적 프로그래밍
* 애스펙트와 템플릿을 통한 반복적인 코드제거

스프링이 수행하는 거의 모든 작업은 이 네 가지 전략 중 하나 이상에 속한다.
앞으로 스프링이 자바 개발을 간소화 하는 방법에 대한 구체적인 예제를 살펴보면서 이와 같은 사상을 확장해 나갈 것이다.  
먼저 스프링이 POJO 지향 개발을 통해 어떻게 침투적 개발을 최소화 할 수 있는지부터 알아보자.  

### POJO의 힘
장기간의 자바 개발 경험이 있다면 인터페이스의 구현이나 클래스의 확장을 강요하는 프레임워크를 본 적이 있고, 심지어 이런 프레임워크로 작업한 경험도 있으리라 생각된다.  
이런 침략적인 프로그래밍 모델의 쉬운 예는 EJB 2시대의 무상태 세션 빈이다.  
초창기 EJBs가 침투적 프로그래밍의 쉬운 예라고는 하지만, 침투적 프로그래밍은 스트러츠와 웹워크 태피스트리 및 수 많은 다른 자바 명세와 프레임워크 초기 버전에서 쉽게 발견된다.  
  
스프링은 API를 이용하여 애플리케이션 코드의 분산을 가능한 한 막는다. 스프링은 스프링에 특화된 인터페이스 구현이다. 스프링 자체에 의존성이 높은 클래스 확장을 거의 요구하지 않는다. 스프링 기반 애플리케이션의 클래스에는 스프링이 사용한다는 표시고 거의 없다. 최악의 경우, 클래스에 스프링 애너테이션이 붙지만 그렇지 않은 경우에는 POJO이다.

이해를 위해 아래의 HelloWorldBean 클래스를 살펴보자.
  
[예제](./../sources/SpringInAction/src/com/springinaction/spring/HelloWorldBean.java)
  
보다시피 이것은 간단하고 흔한 자바 클래스, 즉 POJO다.
스프링 컴포넌트라고 가리키는 것외에 마땅한 특징은 없다. 스프링의 비 침투적 프로그래밍 모델에서, 이 클래스는 스프링 애플리케이션 외에서도 잘 동작한다.  

간단한 형태에세도 불구하고 POJO는 매우 강력하다. 스프링이 POJO에 힘을 불어 넣는 방법 중 하나는 DI를 활용하는 조립이다. 그럼 DI를 통해 애플리케이션 객체 상호 간의 결합도를 낮추는 방법을 알아보자.

### 종속객체 주입
종속 객체 주입이라는 문구가 다소 위협적으로 들려서 복잡한 프로그래밍 기술의 개념이나 디자인 패턴이 떠오른다. 하지만 DI는 생각 만큼 복잡하지 않다. 사실 프로젝트에 DI를 적용해 보면 코드가 훨씬 더 간단해지고 이해하기 쉬우며, 테스트하기도 쉬워진다. 

#### DI동작 방법
HelloWorld예제보다 복잡한 실제 애플리케이션에서는 두 개 이상의 클래스가 서로 협력하여 비즈니스 로직을 수행한다. 이떄 각 객체는 협력하는 객체에 대한 레퍼런스를 얻을 책임이 있다. 그 결과 결합도가 높아지고 테스트하기 힘든 코드가 만들어지기 쉽다.  

예를 들어 코드 1.2에 있는 Knight 클래스를 생각해 보자.  
[예제](./../sources/SpringInAction/src/com/springinaction/spring/DamselRescuingKnight.java)

보다시피 DameslRescuingKnight는 생성자 안에 RescueDamselQuest를 생성한다. 이것은 DameselRescuingKnight가 RescueDamselQuest와 강하게 결합되도록 하며, Knight의 원정 출정 목록을 심각하게 제한한다. 도움이 필요한 여성이 있는 곳에 기사도 있다. 하지만 용을 물리처야 하거나 원탁이 필요하다면, 또한 순회하려면 그냥 앉아만 있어야 한다.  

게다가 DameslRescuingKnight에 대한 단위 테스트를 작성하기도 몹시 어렵다. 단위 테스트에서는 기사의 embarkOnQuest() 메서드가 호출 될 떄 quest의 embark() 메서드 호출을 확인하고 싶다. 하지만 여기서는 이를 수행하는 명확한 방법이 없다, 안타깝게도 DamselRescuingKnight는 테스트 하지 못한 채로 남아 있다.  

결합도가 높은 코드는 한편으로 테스트와 재활용이 어렵고 이해하기도 어려우며, 오류를 하나 수정하면 다른 오류가 발생하는 경향도 있다. 반면에 전혀 결합이 없는 코드는 아무것도 할 수 없다. 무언가를 쓸 만한 일을 하려면 클래스들끼리 어떻게든 서로 알고 있어야 한다. 결합은 필요하지만 주의해서 관리해야 한다.  

DI를 이용하면 객체는 시스템에서 각 객체를 조율하는 제 3자에 의해 생성 시점에 종속객체가 의존성이 부여된다. 객체는 종속객체를 생성하거나 얻지 않아야 되며, 종속객체는 종속객체가 필요한 객체에 등록 되는 것이 DI이다.  

이 의미를 설명하기 위해 코드 아래 예제에 있는 BraveKnight를 살펴보자. 이 클래스는 용감할 뿐만 아니라 발생한 어떤 종류의 원정도 떠날 수 있다.  
[예제](./../sources/SpringInAction/src/com/springinaction/spring/BraveKnight.java)  

보다시피 DamselRescuingKnight와 달리 BraveKnight는 자신의 원정을 생성하지 않는다. 그 대신 생성 시점에 생성자 인자에 원정이 부여 된다. 이와 같은 종류의 종속객체 주입은 생성자 주입 이다.  

개다가 부여된 원정은 모든 원정 구현 인터페이스인 Quest 타입으로 제공된다. 따라서 BraveKnight는 RescueDamselQuest, SlayDragonQuest 등 부여된 다른 Quest를 구현할 수 있다.  

요점은 BraveKnight가 Quest의 특정 구현체에 결합되지 않는다는 사실이다. Quest인터페이스를 구현하기만 하면 기사에서 어떤 종류의원정을 떠나고록 요청하든 문제가 되지 않는다. 이 것이 바로 DI의 주요 이점인 느슨한 결합도이다. 어떤 객체가 자신이 필요러 하는 종속 객체를 인터페이스를 통해서만 알고 있다면 사용하는 객체 쪽에서 아무런 변경 없이 종속 객체(의존성)을 다른 구현체로 바꿀 수 있다.  

실제 종속 객체를 바꾸는 가장 일반적인 방법 중 하나는 테스트 하는 동안의 모의 구현체를 이용하는 것이다. 강한 결합도로 인해 DamselRescuingKnight를 적절히 테스트할 수 없지만. 아래 예제와 같이 Quest의 모의 구현체를 제공하여 BraveKnight를 쉽게 테스트 할 수 있다.  
[예제](./../sources/SpringInAction/src/com/springinaction/spring/BraveKnightTest.java)  

여기서는 Quest 인터페이스의 모의 구현체를 만들기 위해 Mockito로 알려진 모의 객체 프레임워크를 사용했다. 모의 객체가 생겼으면 BraveKnight의 새로운 인스턴스를 생성하고 생성자를 통해 모의 Quest를 주입한다. embarkOnQuest 메서드를 호출한 후에는 Mockito에게 Quest의 embark메서드가 정확히 한 번 호출 됐는지 확인한다.  

#### 기사에게 원정 임무 주입
이렇게 해서 BraveKnight 클래스는 모든 원정 임무를 부여받을 수있게 됐다. 그러면 이제 BraveKnight 클래스에 어떤 Quest를 부여할지를 어떻게 지정할 수있을까? 예를 들어 BraveKnight가 용을 물리치는 원정에 출정하길 원한다고 가정하자. 아마도 아래 예제에 보이는 SlayDragonQuest가 적절할 것이다.  
[예제](./../sources/SpringInAction/src/com/springinaction/spring/SlayDragonQuest.java) 

보다시피 SlayDragonQuest는 Quest 인터페이스를 구현하지만 BraveKnight에 적합하다. 또한 대부분의 시작용 자바 샘플처럼 System.out.println()에 의존하기보다는 SlayDragonQuest는 좀더 일반적인 방법으로 생성자를 통해 PringStream에 요청한다는 것을 눈치챘을지도 모르겠다. 여기서 중요한 질문은 바로 "어떻게 BraveKnight에게 SlayDragonQuest를 줄 수 있을 가?"그리고 어떻게 SlayDragonQuest에게 PrintStream을 줄 수 있을까 하는 것이다.  

애플리케이션 컴포넌트 간의 관계를 정의 하는 것을 와이어링 이라고 한다. 스프링에서 컴포넌트를 와이링 하는 방법은 여러 가지가 있지만. 가장 일반적인 방법은 XML을 이용하는 방법이다. 아래 코드는 스프링 설정 파일을 작성하는 방법이다.  
[예제](./../sources/SpringInAction/src/com/springinaction/spring/KnightConfig.java) 

여기서 BraveKnight와 SlayDragonQuest가 스프링의 빈으로 선언되었다. BraveKnight빈의 경우 생성되면서 레퍼런스를 SlayDragonQuest빈에게 넘겨주며 생성자의 인자가 된다. 반면 SlayDragonQuest 빈 선언은 스프링의 표현언어를 사용하여 System.out을 SlayDragonQuest의 생성자에게 넘긴다.  

만약 XML 설정 방법이 마음에 들지 않으면 스프링에서는 자바를 이용하여 설정 할 수 있다.
그 예로 아래 예제는 XML을 이용한 설정과 동일하다.  
[예제](./../sources/SpringInAction/src/com/springinaction/spring/SlayDragonQuest.java) 

XML 기반의 설정이든 자바 기반의 설정이든 DI의 이점은 같다. 비록 BraveKnight가 Questdp 의존적이기는 하지만. 어떤 타입의 Quest가 주어질지 또는 그 Quest가 어디에서부터 올지는 모르는 것이다. 마찬가지로 SlayDragonQuest가 PrintStream에 의존적이기는 하지만. PrintStream이 어떻게 돌아 가는지 알고서 코딩되는 것은 아니다. 오직 스프링만이 모든 조각이 어떻게 합쳐지는지 설정을 통해 아는 것이다. 이것을 통하여 종속된 클래스를 수정하지 않으면서도 종속성 수정이 가능하다.  

이 예제는 스프링에서 빈을 와이어링 하는 간단한 예를 보여준다. 지금은 자세한 내용에 신경 쓰지 않아도 된다. 자세한 내용은 2장에서 스프링이 빈을 와이어링하는 또 다른 방법과 스프링이 자동으로 빈을 찾고 빈의 간계를 생성하는 바법을 살펴볼 예정이다.  

BraveKnight와 Quest 사이의 관계를 정의 했으니 XML 설정 파일을 로드하여 애플리케이션을 구동해 볼 차례다.
