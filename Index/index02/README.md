# 빈 와이어링

> 목차
1. [스프링 설정 옵션 알아보기](#스프링-설정-옵션-알아보기)
2. [자동으로 빈 와이어링 하기](#자동으로-빈-와이어링-하기)
3. [자바로 빈 와이어링 하기](#자바로-빈-와이어링-하기)
4. [빈을 XML로 와이어링하기](#빈을-XML로-와이어링하기)
5. [설정 가져오기와 믹싱하기](#설정-가져오기와-믹싱하기)
6. [요약](#요약)

- - -

이 장에서 다룰 내용

* 빈 선언
* 생성자 주입과 세터 주입
* 빈 와이어링
* 빈의 생성과 소멸 제어
- - -

영화가 끝난 후에도 자리에 앉아 엔딩 크레딧이 올라가는 것을 끝까지 보고 있으며, 영화 하나를 제작하더라도 놀라울 절도로 많은 사람이 참여한다는 것을 알 수 있다. 배우, 대본작가, 감독, 제작자, 등 흔히 알고 있는 역활 외에도 작곡가, 특수혀과 담당, 아트 디렉터 또한 영화에서 중요한 역활을 하는 사람들이다. 거기에 세트 조립, 음향기사, 의상, 메이크업 아티스트, 스턴트, 코디네이터, 홍보, 카메라맨 보조, 세트 디자이너, 전기 주임, 식사 조달 담당도 없어서는 안될 사람들이다.  

이 많은 사람이 서로 대화도 없이 일을 하는 경우 영화가 어떻게 될지 생각해 보자. 영화 스튜디오에 모인 사람들이 상호 간의 역활 조정 없이 각자 따로따로 일을 한다고 가정해보자, 감독이 큐 사인을 내지 않고 묵묵히 앉아 있으면, 카메라맨도 촬영을 시작하지 못하고 우두커니 기다릴 수 밖에 없다, 하지만 이것은 사소한 문제다. 왜냐하면 여배우는 트레일러에 앉아 나오지도 않고, 고용된 전기 담당자도 없어서 아직 전기도 안 들어왔기 때문이다. 개중에는 정말로 이런 상황에서 만들어지지 않을까 생각이 드는 영화도 있기는 하지만, 대부분의 영화(특히 좋은 영화)는 히트작을 만들겠다는 공통 목표를 향해 수천명의 사람들이 함꼐 일한 결과로 만들어진다.  
소프트웨어도 크게 다르지 않다 아무리 작은 애플리케이션이라도 어떤 비즈니스 목적을 달성하기 위해 협력하는 많은 객체로 구성된다, 수 많은 객체가 자신의 일을 하기 위해 필요한 상대방을 알고 있으며 서로 대화해야 한다. 예를 들어 온라인 쇼핑 애플리케이션의 주문 관리 컴포넌트는 상품관리 컴포넌트 그리고 신용카드 인증 컴포넌트와 함꼐 일해야 한다. 또한 각 컴포넌트는 데이터베이스를 읽고 쓰기 위해서 데이터 액세스 컴포넌트와 협력해야 한다.  

하지만 1장에서 살펴보았듯이 객체 생성이나 검색을 통하여 애플리케이션 갹채 사이에 관계를 형성하는 전통적인 접근 방법은, 재사용과 단위테스트가 어려운 복자반 코드가 작성되게 만든다. 운이 좋다 해도 여전히 객체들은 원래 할 일 보다 많은 일을 해야 한다, 운이 나쁘면 서로의 결합도가 높아져서 재사용도 테스트도 모두 어려운 구조가 된다.  

스프링을 사용하는 애플리케이션은 각 객체가 자신의 일을 하기 위해 필요한 다른 객체를 직접찾거나 생성할 필요가 없다. 컨테이너가 협업할 객체에 대한 레퍼런스를 주기 때문이다. 예를 들어, 주문관리 컴포넌트의 경우 신용카드 인증 컴포넌트가 필요해도 이 컴포넌트를 직접 생성할 필요가 없다. 그냥 가만히 손만 들고 있으면 누군가가 필요한 걸 쥐어 준다.  

애플리케이션 객체간의 이러한 연관관계 형성 작업이 바로 종속객체 주입 개념의 핵심이며 이를 보통 와이어링이라 한다. 이번 장에서는 스프링을 이용한 빈 와이어링의 기초를 다룬다. DI는 스프링의 가장 밑바탕을 이루는 개념이므로 스프링 기반 애플리케이션을 개발 할때는언제나 이용하게 되는 기법이다.  

## 스프링 설정 옵션 알아보기

1장에서 언급했듯이 스프링 컴테이너는 애플리케이션 내에서의 빈 생성 및 DI를 통해서 그러한 객체 사이에 관계 조정에 책임을 지고 있다. 하지만 어떤 빈을 생성할지 그들을 어떻게 엮을지 스프링에서 말해 주는 것은 개발자로서 당신의 책임이다. 빈 와이어링 명세서를 나타내는 데 있어 스프링은 믿을 수 없을 정도로 유연하며, 세 가지 기본적인 와이어링 메커니즘을 제공한다.  

* XML 에서의 명시적 설정
* 자바에서의 명시적 설정
* 내재되어 있는 빈을 찾아 자동으로 와이어링하기

언뜻 보기에는 이러한 세 가지 설정 옵션을 제공하는 것이 스프링을 복잡하게 만드는 것처럼 보일지도 모른다. 각각의 설정 테크닉이 제공하는 것에는 겹치는 부분이 있고, 어느 기술이 주어진 상황에 가장 적용할 만한지 결정하기 어려울 수 있다. 그러나 너무 상심하지 말자, 대부분이 이 선 택은 개인 취향의 문제이며 마음에 는 것으로 선택한다.

스프링에서 빈을 어떻게 와이어링 할지 다양한 선택을 할 수 있는건 좋지만, 하나를 고르긴해야 한다.  

여기에 정해진 정답은 없다. 어떤 방법을 선택하든 프로젝트에 적절하게 사용할 수 있다. 그리고 누가 하나의 선택만 해야 한다고 말하던가? 스프링의 설정 스타일은 짜맞추는 것이므로 어떤빈을 와이어링하귀 위해 XML을 선택할 수도 있고, 스프링의 자바 기반 설정을 사용할 수도 있다.  

그렇긴 하지만, 한 수 있다면 자동 설정을 추천한다. 명시적인 설정이 적을 수록 좋다. 명시적 인 빈 설정을 해야 할 때에는 타입 세이프를 보장하고 더욱 강력한 자바 설정을 XML설정 보다 선호한다, 마지막으로 사용하고자 하는 XML 네임스페이스의 기능이 JAVA설정에 없을 경우 XML을 선호한다.  

이 세 가지 테크닉을 이번 장에서 상세하게 알아볼 것이며 이 책의 전체에 적용해 보자. 지금은 맛보기 테스트를 하며 각각이 어떤지를 알아보자. 스프링 설정에 대한 첫 번쨰 맛보기로 스프링 자동 설정을 살펴보자.  

## 자동으로 빈 와이어링 하기

이번 장의 뒷부분에서는 자바의 XML에서 스프링 와이어링을 나타내는 방법을 보게 된다. 명시적 와이어링 테크닉의 많은 쓰임세를 보겠지만, 사용의 용이성 측명에서 스프링 자동 설정보다 나은 것은 없다. 스프링이 자동으로 설정된다면 명시적 와이어링 빈을 건드릴 필요가 있을까?  

스프링은 두 가지 방법으로 오토 와이어링을 수행한다.  

* 컴포넌트 스캐닝 - 스프링은 애플리케이션 컨텍스트에서 생성되는 빈을 자동으로 발견한다.
* 오토와이어링 - 스프링은 자동으로 빈 의존성을 충족시킨다.


컴포넌트 스캐닝과 오토와이어링을 모두 사용하면 강력하고 명시적 설정을 최소한으로 유지 하는데 도움이 된다.  

컴포넌트 스캐닝과 오토 와이어링 개념을 설명하기 위해 스테레오 시스템의 몇 가지 컴포넌트를 나타내는 몇 개의 빈을 만들어 보자. CompactDisc 클래스를 만들면 스프링이 시작 시에 이를 발견해서 빈을 생성한다. 그리고 CDPlayer 클래스를 만들면 스프링이 이를 발견하고 여기에 CompactDisc 빈을 주입한다.  
[예제](./../../sources/SpringInAction/src/com/springinaction/beanwireing/CompactDisc.java)  

### 발견 가능한 빈 만들기

CompactDisc 인터페이스의 스팩은 중요하지 않다. 중요한 점은 인터페이스를 정의했다는 점이다. 인터페이스로서 CD플레이어는 CD에서 동작하는 계약을 정의한다. 그리거 어떤 CD플레이어 구현과 CD 그 자체 사이에 최소한의 컴플링을 유지한다.

하지만 여전히 CompactDisc의 구현이 필요하다. 실제로 여러 개의 CompactDisct 구현을 가질 수 있다. 이 경우에 다음 코드에 나오는 SgpPeppers 클래스를 가지고 시작한다.  
[예제](./../../sources/SpringInAction/src/com/springinaction/beanwireing/SgtPeppers.java)

CompactDisc 인터페이스를 사용할 떄 SgtPeppers 스펙은 중요하지 않다. SgtPeppers가 @Component를 가지고 애너테이션됨을 주목해야 한다. 간단한 애너테이션은 클래스가 컴포넌트 클래스임을 나타내고, 클래스를 빈으로 만들어야 함을 스프링에 단서로 제공한다. SgtPeppers 빈을 명시적으로 설정할 필요는 없다.

이 클래스는 @Component로 애노테이션되었으므로 스프링이 빈으로 만든다. 하지만 컴포넌트 스캐닝은 기본적으로 켜 있지는 않다. 스프링을 통해 @Component으로 애노테이션된 클래스를 찾기 위해 명시적으로 설정을 작성할 필요가 있다. 다음 코드에서 이를 가능하게 할 최소한의 설정을 보여준다.  
[예제](./../../sources/SpringInAction/src/com/springinaction/beanwireing/CDPlayerConfig.java)

CDPlayerConfig 클래스는 자바로 스프링 와이어링 스펙을 정의한다. 자바 기반의 스프링설정에 대해서는 다음절에서 더 살펴본다. 그러나 지금은 CDPlayerConfig는 명시적으로 어떤 빈도 정의하지 않는다. 대신 스프링으로 컴포넌트 스캐닝을 가능케 하기 위해서 @ConponentScan으로 애노테이션 되었다.

더이상의 설정 없이 @ComponentScan은 설정 클래스이므로 동일한 클래스를 기본 스캐닝한다. 따라서 CDPlayerConfig는 자신의 패키지와 하위 패키지를 스캔하고 @Component로 애노테이션 된 클래스를 찾는다. CompactDisc클래스를 찾고 자동으로 스프링으로 빈을 만든다.

XML설정을 통해서 컴포넌트 스캐닝을 활성화하려면 그떄는 스프링의 컨텍스트를 네임스페이스로 하여 `<context:component-scan>` 요소를 사용한다. 다음은 컴포넌트 스캐닝을 활성화 하기 위한 최소한의 XML설정이다.  
[예제](./../../sources/SpringInAction/src/com/springinaction/beanwireing/CDPlayerConfig.xml)

비록 XML이 컴포넌트 스캐닝을 가능케 하는 옵션이지만, 이 책에서는 더 선호하는 자바 기반의 설정을 사용하는데 집중한다. XML이 더 스타일리시하긴 해도 이 책은 자바를 더 집중적으로 다룬다.  

믿건 밎지 않건, 두 개의 클래스만으로 우리는 이미 무언가를 할 준비가 되었다. 컴포넌트 스캐닝 작업을 테스트하기 위해서 스프링 애플리케이션 컨텍스트 생성과 CompactDisc 빈이 생성되었는지를 알기 위한 간단한 Junit 테스트를 만든다. 다음 코드의 CDPlayerTest가 바로 그 테스트이다.  
[예제](./../../sources/SpringInAction/src/com/springinaction/beanwireing/CDPlayerTest.java)

CDPlayerTest는 테스트 시작 시 자동으로 생성되는 스프링 애플리케이션 컨텍스트를 가지는 스프링 SpringJUnit4ClassRunner을 이용한다. @ContextConfiguration 애노테이션은 CDPlayerConfig 클래스를 통해서 설정을 로드한다. 설정 클래스는 @ComponentScan을 가지므로 결과 애플리케이션 컨텍스트는 CompactDisct 빈을 포함한다.

증명을 위해 테스트 클래스는 CompactDisc 빈을 테스트로 주입하는 @Autowired로 애노테이션된 CompactDisc 타입 프로퍼티를 가진다(@Autowired에 대해선 더 자세히 이야기 할것이다.) 결국, 간단한 테스트 메소드는 cd 프로퍼티가 null이 아님을 확인한다. 널이 아니라는 것은 스프링이 CompactDisc클래스를 찾아서 스프링 애플리케이션 컨텍스트에서 빈으로 자동 생성하고 테스트로 주입한다.

테스트는 훌룡하게 통과할 것이다. 첫 번쨰 간단한 컴포넌트 스캐닝 연습은 성공이다. 비록 하나의 빈을 만들기 위해서 컴포넌트 스캐닝을 사용햔 경우라도, 동일한 작은 설정량으로 다수의 빈을 생성하고 커버할 수 있다. @Component로 애노테이션 된 패키지와 그 하위의 클래스는 빈으로 생성된다.

@ComponentScan한 줄로 수 많은 빈을 자동으로 생성하게 하는 것은 좋은 거래다. @ComponentScan과 @Component를 더 깊게 살펴보고, 컴포넌트 스캐닝으로 다른 무엇을 할 수 있는지 살펴보자.

### 컴포넌트 스캔된 빈 명명하기

스프링 애플리케이션 컨텍스트에서 모든 빈은 ID가 주어진다. 이전 예제에서 확실하게 제시 되지 않은 이유는 SgtPeppers 빈의 ID가 명시적으로 주어지지 않아도 클래스 명으로부터 유추되어 할당되었기 떄문이다. 특히 궤적으로 빈은 클래스 명의 첫 글자를 소문자로 바꾼 sgtPepper ID를 가진다. 만약 빈에 다른 ID를 주고 싶다면 해야 할 일은 @Component 애너테이션에 원하는 ID를 값으로 넣어 주는 것이 전부다. 예를 들어 lonelyHeartClub으로 빈을 구별하고자 한다면 @Component를 가지고 SgtPeppers 클래스에 아래와 같이 적용한다.

```java
@Component("lonelyHeartsClub")  
public class SgtPeppers implements CompactDisc {
    ...
}
```

빈의 이름을 부여하는 다른 방법에서는 @Component 애너테이션을 더 이상 사용하지 않는 대신 빈 ID를 제공하기 위해서 자바 종속객체 주입 DI에 스펙에 정의 되어 있는 @Names 애너테이션을 사용한다.

```java
@Named("lonelyHeartsClub")
public class SgtPeppers implements CompactDisc {
    ...
}
```

스프링은 @Component의 대안으로 @Names 애너테이션을 지원한다. 미묘한 차이가 있지만 대부분의 경우 호환 가능하다.

이미 말했듯이 이 책에서는 @Component 애너테이션을 아주 선호하며 @Named보다 @Component가 더 많이 사용된다. 따라서 더 이상 @Named 를 사용하지 않고 예제에서도 사용하지 않을 것이다.

### 컴포넌트 스캐닝을 위한 베이스 패키지 세팅

지금까지 애트리뷰트 없이 @ComponentScan을 사용하였다. 컴포넌트 검색을 위한 베이스 패키지로서 설정 클래스 패키지가 기본이라는 의미이다. 그렇지만 다른 패키지를 원한다면 또는 다중 베이스 패키지를 스캔해야 한다면?  

베이스 패키지를 명시적으로 세팅해야 하는 한 가지 공통 이유는 애플리케이션 코드와 분리하여 설정 코드를 패키지 안에서 보관할 수 있기 때문이다. 그 경우 기본 베이스 패키지를 이용하는 것은 불가능하다.

다른 베이스 패키지를 지정하는 방법은 @ComponentScan의 값 속성에 기술하는 것 뿐이다.

```java
@Configuration
@ComponentScan("com.springinaction.beanwireing")
public class CDPlayerConfig{
    ...
}
```

또는 베이스 패키지를 설정하는 것을 보다 며오학히 하고 싶으면 basePackages 애트리뷰트를 사용한다.

```java
@Configuration
@ComponentScan(basePackages="com.springinaction.beanwireing")
public class CDPlayerConfig {
    ...
}
```

아마 basepackages가 복수형이라는 걸 눈치 챘을 것이다. 여러 개의 베이스 패키지를 지정할 수 있는지 궁금할 텐데, 할 수 있다, 패키지 배열에 대해 basePackages가 스캔되도록 설정하기만 하면 된다.

```java
@Configuration
@ComponentScan(basePackages={"com.springinaction.beanwireing", "com.springinaction.spring"})
public class CDPlayerConfig {
    ...
}
```

여기서 보이는 것과 같은 베이스 페키지 설정은 String 값으로 표시된다, 이는 충분하지만 타입 세이프 하지는 않다, 패키지 이름을 변경한다면 작성했던 베이스 패키지가 잘못될 수 있다.

패키지를 간단한 String 값으로 지정하지 않고, @ConponentScan에서 옵션으로 제공하는 패키지 내의 클래스나 인터페이스를 사용할 수 있다.

```java
@Configuration
@ComponentScan(basePackagesClasses={CDPlater.class, DVDPlayer.class})
public void CDPlayerConfig {
    ...
}
```

basePackages 애트리뷰트는 basePackageClasses로 교체 된다. String 이름을 사용하여 패키지 안에 있는 컴포넌트 스캐닝을 위한 베이스 패키지로서 사용된다.

비록 이 책에서는 basePackageClasses에 컴포넌트 클래스를 지정했지만, 스캔될 패키지 안의 비어 있는 마커 인터페이스 생성을 고려해야 한다. 마커 인터페이스를 사용하면, 리팩토링이 쉽도록 인터페이스에 대한 레퍼런스만 가지게 되고, 실제 애플리케이션 코드에 대한 레퍼런스를 사용하지 않을 수 있다.

SgtPeppers 빈처럼 애플리케이션의모든 객체가 혼자이고 의존성이 없다면, 컴포넌트 스캔으로 충분하다. 그러나 많은 객체는 일을 처리 하기 위해 다른 객체에 의존관계를 가진다. 의존성을 가지고 컴포넌트 스캔된 빈을 묶기 위한 방법이 필요하다. 이를 위해서 자동 스프링 설정의 다른 측면인 오토와이어링이 필요하다.

#### 오토 와이어링 되는 빈의 애너테이션

오토와이어링은 스프링이 빈의 요구 사항과 매칭되는 애플리케이션 컨텍스트 상에서 다른 빈을 찾아 빈 간의 의존성을 자동으로 만족시키도록 하는 수단이다. 오토와이어링 수행을 하도록 지정하기 위해서는 다음 스프링의 @Autowired 애너테이션을 사용한다.

예를 들어 다음 코드의 CDPlayer 클래스를 보자. 생성자는 @Autowired가 걸려 있는데, 이 애너테이션은 스프링이 CDPlayer 빈응 생성할 때, 생성자를 통해서 인스턴스화하고 CompactDisc에 대입 가능한 빈을 전달해 준다.
